/**
 * Kiro IDE Server Mock
 * Provides a mock implementation for development and testing
 */

import { KiroProject, KiroFile, KiroFileTree, KiroTerminal, KiroAIAssistance } from './kiro-client'

// In-memory storage for mock data
const mockProjects: Map<string, KiroProject> = new Map()
const mockFiles: Map<string, Map<string, KiroFile>> = new Map()
const mockTerminals: Map<string, KiroTerminal> = new Map()

// Initialize with sample project
const sampleProject: KiroProject = {
  id: 'sample-project',
  name: 'Sample Project',
  description: 'A sample Next.js project',
  type: 'web',
  framework: 'nextjs',
  language: 'typescript',
  structure: {
    name: 'sample-project',
    type: 'directory',
    path: '/',
    children: [
      { name: 'src', type: 'directory', path: '/src', children: [
        { name: 'app', type: 'directory', path: '/src/app', children: [
          { name: 'page.tsx', type: 'file', path: '/src/app/page.tsx' },
          { name: 'layout.tsx', type: 'file', path: '/src/app/layout.tsx' }
        ]},
        { name: 'components', type: 'directory', path: '/src/components', children: [] }
      ]},
      { name: 'package.json', type: 'file', path: '/package.json' },
      { name: 'README.md', type: 'file', path: '/README.md' }
    ]
  },
  createdAt: new Date().toISOString(),
  updatedAt: new Date().toISOString()
}

mockProjects.set(sampleProject.id, sampleProject)

// Mock file contents
const sampleFiles = new Map([
  ['/src/app/page.tsx', {
    path: '/src/app/page.tsx',
    content: `export default function Home() {
  return (
    <main className="flex min-h-screen flex-col items-center justify-between p-24">
      <h1 className="text-4xl font-bold">Welcome to Sample Project</h1>
      <p>Edit src/app/page.tsx to get started</p>
    </main>
  )
}`,
    language: 'typescript'
  }],
  ['/src/app/layout.tsx', {
    path: '/src/app/layout.tsx',
    content: `import type { Metadata } from 'next'

export const metadata: Metadata = {
  title: 'Sample Project',
  description: 'Generated by Kiro IDE',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  )
}`,
    language: 'typescript'
  }],
  ['/package.json', {
    path: '/package.json',
    content: JSON.stringify({
      name: 'sample-project',
      version: '0.1.0',
      private: true,
      scripts: {
        dev: 'next dev',
        build: 'next build',
        start: 'next start',
        lint: 'next lint'
      },
      dependencies: {
        next: '14.0.0',
        react: '^18.2.0',
        'react-dom': '^18.2.0'
      },
      devDependencies: {
        '@types/node': '^20',
        '@types/react': '^18',
        '@types/react-dom': '^18',
        typescript: '^5'
      }
    }, null, 2),
    language: 'json'
  }]
])

mockFiles.set(sampleProject.id, sampleFiles)

export class KiroServerMock {
  // Project operations
  static async createProject(project: Omit<KiroProject, 'id' | 'createdAt' | 'updatedAt'>): Promise<KiroProject> {
    const id = Math.random().toString(36).substring(7)
    const newProject: KiroProject = {
      ...project,
      id,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    }
    
    mockProjects.set(id, newProject)
    mockFiles.set(id, new Map())
    
    // Create initial files based on structure
    this.createFilesFromStructure(id, newProject.structure)
    
    return newProject
  }

  static async getProject(projectId: string): Promise<KiroProject> {
    const project = mockProjects.get(projectId)
    if (!project) {
      throw new Error('Project not found')
    }
    return project
  }

  static async listProjects(): Promise<KiroProject[]> {
    return Array.from(mockProjects.values())
  }

  static async saveProject(projectId: string): Promise<void> {
    const project = mockProjects.get(projectId)
    if (!project) {
      throw new Error('Project not found')
    }
    project.updatedAt = new Date().toISOString()
  }

  // File operations
  static async readFile(projectId: string, path: string): Promise<KiroFile> {
    const projectFiles = mockFiles.get(projectId)
    if (!projectFiles) {
      throw new Error('Project not found')
    }
    
    const file = projectFiles.get(path)
    if (!file) {
      throw new Error('File not found')
    }
    
    return file
  }

  static async writeFile(projectId: string, path: string, content: string): Promise<void> {
    const projectFiles = mockFiles.get(projectId)
    if (!projectFiles) {
      throw new Error('Project not found')
    }
    
    const file = projectFiles.get(path) || { path, content: '', language: this.getLanguageFromPath(path) }
    file.content = content
    projectFiles.set(path, file)
  }

  static async createFile(projectId: string, path: string, content: string = ''): Promise<void> {
    const projectFiles = mockFiles.get(projectId)
    if (!projectFiles) {
      throw new Error('Project not found')
    }
    
    projectFiles.set(path, {
      path,
      content,
      language: this.getLanguageFromPath(path)
    })
  }

  static async deleteFile(projectId: string, path: string): Promise<void> {
    const projectFiles = mockFiles.get(projectId)
    if (!projectFiles) {
      throw new Error('Project not found')
    }
    
    projectFiles.delete(path)
  }

  static async renameFile(projectId: string, oldPath: string, newPath: string): Promise<void> {
    const projectFiles = mockFiles.get(projectId)
    if (!projectFiles) {
      throw new Error('Project not found')
    }
    
    const file = projectFiles.get(oldPath)
    if (!file) {
      throw new Error('File not found')
    }
    
    projectFiles.delete(oldPath)
    file.path = newPath
    projectFiles.set(newPath, file)
  }

  // Terminal operations
  static async createTerminal(config?: Partial<KiroTerminal>): Promise<KiroTerminal> {
    const id = Math.random().toString(36).substring(7)
    const terminal: KiroTerminal = {
      id,
      name: config?.name || `Terminal ${mockTerminals.size + 1}`,
      shell: config?.shell || '/bin/bash',
      cwd: config?.cwd || '/',
      env: config?.env || {}
    }
    
    mockTerminals.set(id, terminal)
    return terminal
  }

  static async closeTerminal(terminalId: string): Promise<void> {
    mockTerminals.delete(terminalId)
  }

  // AI assistance
  static async getAISuggestions(projectId: string, file: string): Promise<KiroAIAssistance> {
    // Mock AI suggestions
    return {
      suggestions: [
        {
          id: 'suggest-1',
          type: 'code',
          title: 'Add Error Boundary',
          description: 'Wrap your component with an error boundary to handle runtime errors gracefully',
          priority: 'medium',
          changes: [{
            file,
            changes: [{
              range: {
                start: { line: 0, character: 0 },
                end: { line: 0, character: 0 }
              },
              newText: 'import { ErrorBoundary } from \'react-error-boundary\'\n\n'
            }]
          }]
        },
        {
          id: 'suggest-2',
          type: 'performance',
          title: 'Optimize Re-renders',
          description: 'Use React.memo to prevent unnecessary re-renders',
          priority: 'low',
          changes: []
        }
      ],
      diagnostics: [
        {
          file,
          line: 10,
          column: 5,
          severity: 'warning',
          message: 'Missing dependency in useEffect',
          code: 'react-hooks/exhaustive-deps',
          fixes: [{
            title: 'Add missing dependency',
            changes: [{
              file,
              changes: [{
                range: {
                  start: { line: 10, character: 20 },
                  end: { line: 10, character: 22 }
                },
                newText: '[dependency]'
              }]
            }]
          }]
        }
      ],
      refactorings: [
        {
          id: 'refactor-1',
          name: 'Extract Component',
          description: 'Extract this JSX into a separate component',
          scope: 'function',
          preview: []
        }
      ],
      completions: []
    }
  }

  static async getCompletions(file: string, position: { line: number; character: number }): Promise<any[]> {
    // Mock code completions
    return [
      {
        label: 'useState',
        kind: 'function',
        detail: 'React Hook',
        documentation: 'Returns a stateful value, and a function to update it.',
        insertText: 'useState(${1:initialState})'
      },
      {
        label: 'useEffect',
        kind: 'function',
        detail: 'React Hook',
        documentation: 'Accepts a function that contains imperative, possibly effectful code.',
        insertText: 'useEffect(() => {\n  $0\n}, [])'
      }
    ]
  }

  static async runDiagnostics(projectId: string): Promise<any[]> {
    // Mock diagnostics
    return [
      {
        file: '/src/app/page.tsx',
        line: 5,
        column: 10,
        severity: 'info',
        message: 'Consider using semantic HTML elements',
        code: 'a11y-semantic'
      }
    ]
  }

  // Helper methods
  private static createFilesFromStructure(projectId: string, structure: KiroFileTree): void {
    const projectFiles = mockFiles.get(projectId) || new Map()
    
    const traverse = (node: KiroFileTree) => {
      if (node.type === 'file') {
        projectFiles.set(node.path, {
          path: node.path,
          content: node.content || '',
          language: this.getLanguageFromPath(node.path)
        })
      } else if (node.children) {
        node.children.forEach(traverse)
      }
    }
    
    traverse(structure)
    mockFiles.set(projectId, projectFiles)
  }

  private static getLanguageFromPath(path: string): string {
    const ext = path.split('.').pop()?.toLowerCase()
    const languageMap: Record<string, string> = {
      ts: 'typescript',
      tsx: 'typescript',
      js: 'javascript',
      jsx: 'javascript',
      json: 'json',
      md: 'markdown',
      css: 'css',
      scss: 'scss',
      html: 'html',
      py: 'python',
      go: 'go',
      rs: 'rust',
      java: 'java',
      cpp: 'cpp',
      c: 'c',
      yaml: 'yaml',
      yml: 'yaml',
      xml: 'xml'
    }
    
    return languageMap[ext || ''] || 'plaintext'
  }
}